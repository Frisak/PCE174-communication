#!/usr/bin/env python3
"""pce174 - a little tool to communicate with a PCE-174 lightmeter/logger
"""

# todo
#   - Fully implement and test structs for different data transmissions
#   - implement output decoding -> csv
#   - understand all reading functions
#   - write decoder for status information
#   - implement logging interval setting
#   - add a command to list all available command arguments
#   - add option to list all valid commands
#   - test all commands!
#   - implement interface detection?
#   - make default device/interface OS dependent

import sys, argparse
import serial
from construct import *
import struct

def main():
    # get commandline arguments
    parser = argparse.ArgumentParser(description="talk to a PCE-174 lightmeter/logger")
    parser.add_argument('command', type=str, help="command to send to instrument")
    parser.add_argument('-i', dest="interface", type=str, default='/dev/ttyUSB0', help="interface to connect to (/dev/ttyUSB0)")
    parser.add_argument('-b', dest="baud", type=int, default=9600, help="baudrate (9600)")
    parser.add_argument('-f', dest="format", type=str, default="csv", choices=['csv','raw','hex','repr'], help="return data in the specified format (csv)")
    args = parser.parse_args()

    if args.command in cmd:
        iface = serial.Serial(args.interface, args.baud, timeout=2)
        hello = b"\x87\x83"	# command prefix
        msg = hello + cmd[args.command]['cmd']
        iface.write(msg)
        if cmd[args.command]['ret']: # read data
            buf = iface.read(100000)
            if args.format == "raw":
                print(buf),
            elif args.format == "repr":
                print(repr(buf)),
            elif args.format == "hex":
                print(buf.encode('hex')),
            elif args.format == "csv":
                print(decode_output(buf)),
        iface.close()
    else:
        print("unknown command:", args.command)
        parser.print_usage()



def decode_output(buf):
    """return decoded data
        XXX Caution: this code is work in progress and probably does not work correctly as of now.
    """

    ret = None
    cmdid = buf[:2]
    buf = buf[2:]

    if cmdid == b"\xaa\xdd":
        "timing data"

        timing_data = Struct(
            "timing data",
            UBInt8('foo'),
            UBInt8('year'),
            UBInt8('week'),
            UBInt8('month'),
            UBInt8('day'),
            UBInt8('hour'),
            UBInt8('minute'),
            UBInt8('second'),
            BFloat32('value'), # XXX is this correct?
            UBInt8('stat0'),
            UBInt8('stat1'),
            UBInt8('mem_no'),
            UBInt8('read_no')
            )
        ret = timing_data.parse(buf)

    elif cmdid == b"\xbb\x88":
        "IIC_MEM_99 data"

        tx_data = Struct(
            "tx data",
            UBInt8('foo'),
            UBInt8('year'),
            UBInt8('week'),
            UBInt8('month'),
            UBInt8('day'),
            UBInt8('hour'),
            UBInt8('minute'),
            UBInt8('second'),
            SBInt16('value'),
            UBInt8('stat0'),
            UBInt8('stat1'),
            )

        ret = tx_data.parse(buf)

    elif cmdid == b"\xaa\xcc":
        "data_logger data"

        logger_data = Struct(
            "tx data",
            UBInt8('foo'),
            UBInt8('year'),
            UBInt8('week'),
            UBInt8('month'),
            UBInt8('day'),
            UBInt8('hour'),
            UBInt8('minute'),
            UBInt8('second'),
            UBInt8('data_h'),
            UBInt8('data_l'),
            UBInt8('stat0'),
            UBInt8('stat1'),
            )
        ret = logger_data.parse(buf)
    

    # XXX implement other data structures


    return(ret)




# command definition
cmd = {
        'units' : { 
            'cmd' : b"\xfe",		# command byte
            'ret' : False,		# will data be returned?
            'desc': "Toggle units between lux and foot candle (fc)"	# description
            },
        'light' : { 
            'cmd' : b"\xfd", 
            'ret' : False,
            'desc': "Toggle backlight"
            },
        'save' : { 
            'cmd' : b"\xfb", 
            'ret' : False,
            'desc': "Mem/setup"
            },
        'peak' : { 
            'cmd' : b"\xf7", 
            'ret' : False,
            'desc': "Toggle peak value display"
            },
        'rel' : { 
            'cmd' : b"\xdf", 
            'ret' : False,
            'desc': "Toggle realtive reading"
            },
        'hold' : { 
            'cmd' : b"\xef", 
            'ret' : False,
            'desc': "Toggle value hold"
            },
        'minmax' : { 
            'cmd' : b"\xbf", 
            'ret' : False,
            'desc': "Toggle Min/Max/current value discplay "
            },
        'logger' : { 
            'cmd' : b"\xdc", 
            'ret' : False,
            'desc': "??? Data logger hold REC"
            },
        'relhold' : { 
            'cmd' : b"\xdb", 
            'ret' : False,
            'desc': ""
            },
        'lighthold' : { 
            'cmd' : b"\xde", 
            'ret' : False,
            'desc': "???"
            },
        'peakhold' : { 
            'cmd' : b"\xda", 
            'ret' : False,
            'desc': "???"
            },
        'range' : { 
            'cmd' : b"\x7f", 
            'ret' : False,
            'desc': "Cycle through measurement ranges"
            },
        'off' : { 
            'cmd' : b"\xf3", 
            'ret' : False,
            'desc': "Turn of the instrument"
            },
        'get-timing' : { 
            'cmd' : b"\x11", 
            'ret' : True,
            'desc': "Timing data transmit"
            },
        'get-stored-data' : { 
            'cmd' : b"\x12", 
            'ret' : True,
            'desc': "read stored data"
            },
        'get-logger-data' : { 
            'cmd' : b"\x13", 
            'ret' : True,
            'desc': "read logger data"
            },
        'get-data-protocol' : { 
            'cmd' : b"\x14", 
            'ret' : True,
            'desc': "data logger data transmit protocol"
            }
        }


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass

# EOF
