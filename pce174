#!/usr/bin/env python3
"""
pce174 

A tool to communicate with a PCE-174 lightmeter/logger
"""

# todo
#   - what hapens if logging in rel mode: negative values?
#   - implement parsing/processing data from files? Woul;d be nice for debuggin or stored raw data
#   - what is memload? is this a usefull name
#   - what is read_no in live data?
#   - find out how to send simultaneous key presses (if possible)
#   - find out if we can set date, time and sampling interval through a command
#   - maybe round output or assemble values in BCD to avoid funny numerical artifacts?
#   - add some checks for data integrity/completeness?
#   - get rid of timeout: rather test for data completeness
#   - test, test, test


import sys, argparse
import serial
import warnings
import binascii
from datetime import *
from collections import OrderedDict
# requires construct â‰¥ 2.8 (tested with 2.9)
from construct import * 

def main():
    "The main function - duh."

    global args
    args = getargs()

    if args.list:
        print("Available commands:\n")
        for key, value in cmd.items():
            print(" ", key)
            print(' '*5, value['desc'])
            print(' '*5, "Button:", value['key'])
            if value['ret']:
                print(' '*5, "Returns data in the specified format (-f)")
            print()
    elif args.command in cmd:
        try:
            iface = serial.Serial(
                    port=args.interface, 
                    baudrate=args.baud, 
                    bytesize=args.bytesize, 
                    parity=args.parity, 
                    stopbits=args.stopbits, 
                    timeout=args.timeout
                    )
        except:
            sys.exit("Unable to connect to device.") 

        blob = send_command(iface, args.command)
        iface.close()

        if cmd[args.command]['ret']: # read data
            if args.format == "raw":
                sys.stdout.buffer.write(blob)
            elif args.format == "hex":
                sys.stdout.buffer.write(binascii.hexlify(blob))
            elif args.format in ("csv", "repr", "construct"):
                print(decode_blob(args.command, blob))
    else:
        sys.exit("Unknown command")


def send_command(iface, command):
    "Send command to instrument"

    hello = b"\x87\x83"	# command prefix
    msg = hello + cmd[args.command]['cmd']
    iface.write(msg)
    
    blob = b''
    if cmd[command]['ret']:
        blob = iface.read(100000)

    return(blob)


def getargs():
    "Return commandline options and arguments"

    parser = argparse.ArgumentParser(description="Talk to a PCE-174 lightmeter/logger")

    parser.add_argument('-l', '--list', dest='list', action='store_true', help="list all available commands")
    parser.add_argument('-i', dest="interface", type=str, default='/dev/ttyUSB0', help="interface to connect to (/dev/ttyUSB0)")
    parser.add_argument('-b', dest="baud", type=int, default=9600, help="baudrate (9600)")
    parser.add_argument('-B', dest="bytesize", type=int, default=8, choices =[8, 7, 6, 5], help="byte size (8)")
    parser.add_argument('-p', dest="parity", type=str, default='N', choices =['N', 'E', 'O', 'M', 'S'], help="parity (N)")
    parser.add_argument('-S', dest="stopbits", type=float, default=1, choices=[1, 1.5, 0], help="stopbits (1)")
    parser.add_argument('-t', dest="timeout", type=float, default=5, help="serial communication timeout [s] (5)")
    parser.add_argument('-f', dest="format", type=str, default="csv", choices=['csv', 'repr', 'construct', 'raw', 'hex'], help="specify output format (csv)")
    parser.add_argument('-s', '--sep', dest="sep", type=str, default=",", help="separator for csv (',')") 
    parser.add_argument('command', nargs='?', type=str, help="command to send to instrument")

    return(parser.parse_args())


def bcd2int(dat):
    "Return the decimal value of a BCD encoded int"

    ret = 0
    f = 1
    while dat != 0:
        val = dat & 0x0f
        if val > 9:
            warnings.warn("Pseudo-tetrade encountered in BCD conversion.")
        ret += f * val
        f *= 10
        dat = dat >> 4
    return(ret)


def decode_blob(cmd, blob):
    "return decoded data"

    ret = None
    if cmd == "get-live-data":
        ret = parse_live_data(blob)
        if args.format in ('csv', 'repr'):
            ret = process_live_data(ret)
        if args.format == ('csv'):
            ret = live_data2csv(ret)
    elif cmd == "get-saved-data":
        ret = parse_saved_data(blob)
        if args.format in ('csv', 'repr'):
            ret = process_saved_data(ret)
        if args.format == ('csv'):
            ret = saved_data2csv(ret)
    elif cmd == "get-logger-data":
        ret = parse_logger_data(blob)
        if args.format in ('csv', 'repr'):
            ret = process_logger_data(ret)
        if args.format == ('csv'):
            ret = logger_data2csv(ret)
    else:
        raise Exception('Unknown command.')

    return(ret)


def parse_live_data(blob):
    "parse live data to construct container"

    Live_data = Struct(
            'magic' / Const(b'\xaa\xdd'),
            Padding(1),
            'year'    / Int8ub,
            'weekday' / Int8ub,
            'month'   / Int8ub,
            'day'     / Int8ub,
            'hour'    / Int8ub,
            'minute'  / Int8ub,
            'second'  / Int8ub,
            'dat0H'   / Int8ub,
            'dat0L'   / Int8ub,
            'dat1H'   / Int8ub,
            'dat1L'   / Int8ub,
            'stat0'   / Int8ub,
            'stat1'   / Int8ub,
            'mem_no'  / Int8ub,
            'read_no' / Int8ub
            )

    return(Live_data.parse(blob))


def process_live_data(rec):
    """Return processed live data

    Accepts a construct container object and returns a dict
    representing the measurement.
    
    Processing comprises the assembly of common time and date formats as well as 
    turning bit fields into human readable values.
    """

    # bcd decoding
    for key in ['year', 'weekday', 'month', 'day', 'hour', 'minute', 'second']:
        rec[key] = bcd2int(rec[key])

    stat0 = decode_stat0(rec['stat0'])
    stat1 = decode_stat1(rec['stat1'])

    # reassemble the record in a more practical format
    rec = {
            'date'     : "20%2.2i-%2.2i-%2.2i" % (rec['year'], rec['month'], rec['day']),
            'time'     : "%2.2i:%2.2i:%2.2i" % (rec['hour'], rec['minute'], rec['second']),
            'value'    : stat1['sign'] * (100*rec['dat1H'] + rec['dat1L']) * stat0['Frange'],
            'rawvalue' : (100*rec['dat0H'] + rec['dat0L']) * stat0['Frange'],
            'APO'      : stat0['APO'],
            'hold'     : stat0['hold'],
            'unit'     : stat0['unit'],
            'range'    : stat0['range'],
            'mode'     : stat0['mode'],
            'power'    : stat1['power'],
            'dispmode' : stat1['dispmode'],
            'memload'  : stat1['memload'],
            'mem_no'   : rec['mem_no'],
            'read_no'  : rec['read_no']
            }

    return(rec)


def live_data2csv(dat):
    "returns csv from live data dict"
    
    # define columns and assemble header
    cols = ('date', 'time', 'value', 'rawvalue', 'unit', 'range', 'mode', 'hold', 'APO', 'power', 'dispmode', 'memload', 'mem_no', 'read_no')
    csv = [args.sep.join(cols)]

    csv.append(args.sep.join(([str(dat[col]) for col in cols])))
    
    return("\n".join(csv))


def parse_saved_data(blob):
    "parse saved data to construct container"

    record = Struct(
            'foo'   / Int8ub, # should be 0x00 but isn't always
            #'magic' / Const(b'\x00'),
            'year'  / Int8ub,
            'week'  / Int8ub,
            'month' / Int8ub,
            'day'   / Int8ub,
            'hour'  / Int8ub,
            'minute'/ Int8ub,
            'second'/ Int8ub,
            'pos'   / Int8ub,
            'datH'  / Int8ub,
            'datL'  / Int8ub,
            'stat0' / Int8ub,
            'stat1' / Int8ub
           )

    db = Struct(
            'magic' / Const(b'\xbb\x88'),
            'data'  / Array(99, record)
            )
    
    return(db.parse(blob))


def process_saved_data(dat):
    """Return processed saved data

    Accepts a construct container object and returns a list of dicts
    Each dict represents one saved measurement.
    
    Processing comprises the assembly of common time and date formats as well as 
    turning bit fields into human readable values.
    """

    dat2 = []
    for rec in dat['data']:
        if rec['pos'] == 0:
            break
        # bcd decoding
        for key in ['year', 'week', 'month', 'day', 'hour', 'minute', 'second']:
            rec[key] = bcd2int(rec[key])

        stat0 = decode_stat0(rec['stat0'])
        stat1 = decode_stat1(rec['stat1'])

        dtime = datetime(2000+rec['year'], rec['month'], rec['day'], rec['hour'], rec['minute'], rec['second'])

        # reassemble the record in a more practical format
        rec = {
                'pos'      : rec['pos'],
                'date'      : dtime.date(),
                'time'      : dtime.time(),
                'value'    : stat1['sign'] * (100*rec['datH'] + rec['datL']) * stat0['Frange'],
                'APO'      : stat0['APO'],
                'hold'     : stat0['hold'],
                'unit'     : stat0['unit'],
                'range'    : stat0['range'],
                'mode'     : stat0['mode'],
                'power'    : stat1['power'],
                'dispmode' : stat1['dispmode'],
                'memload'  : stat1['memload']
                }

        dat2.append(rec)

    return(dat2)


def saved_data2csv(dat):
    "returns csv from live data dict"

    cols = ('pos', 'date', 'time', 'value', 'unit', 'range', 'mode', 'hold', 'APO', 'power', 'dispmode', 'memload')
    csv = [args.sep.join(cols)]
    for rec in dat:
        if rec['pos'] > 0:
            csv.append(args.sep.join(([str(rec[col]) for col in cols])))
    
    return("\n".join(csv))


def parse_logger_data(blob):
    "Decode logger_data to csv"


    Datapoint = Struct(
            'datH'  / Int8ub,
            'datL'  / Int8ub,
            'stat0' / Int8ub,
            'next'  / Peek(Int16ub)
            )

    Group = Struct(
            'magic'     / Const(b'\xaa\x56'),
            'groupno'   / Int8ub,
            'sampling'  / Int8ub,
            'reserved'  / Const(b'\x00\x00'),
            'year'      / Int8ub,
            'weekday'   / Int8ub,
            'month'     / Int8ub,
            'day'       / Int8ub,
            'hour'      / Int8ub,
            'minute'    / Int8ub,
            'second'    / Int8ub,
            'data'      / RepeatUntil(lambda x, lst, ctx: x.next==0xaa56 or x.next==None, Datapoint)
            )

    db = Struct(
            'magic'    / Const(b'\xaa\xcc'),
            'nogroups' / Int8ub,
            'bufsize'  / Int16ub,
            'groups'   / Array(this.nogroups, Group)
            )

    dat = db.parse(blob)

    return(dat)


def process_logger_data(dat):
    """Return processed logger data

    Accepts a construct container object and returns a list of logging groups.
    
    Each group is a list of data points. Datapoints are dicts with the following keys:
    
    groupno   : numerical id of the logging group
    id        : measurement number within the group [0,1, ...]
    sampling  : sampling interval [s]
    date      : YYYY-MM-DD
    time      : HH:MM:SS
    value     : measurement
    unit      : Unit of measurement (lux/fc)
    range     : Measurement range used (40, 400, ... 4000k)
    mode      : normal/Pmin/Pmax/min/max/rel 
    hold      : Was hold active? (hold/cont)
    APO       : Auto-power-off (on/off)

    """

    logger = []
    for group in dat['groups']:
        # bcd decoding
        for key in ['year', 'weekday', 'month', 'day', 'hour', 'minute', 'second']:
            group[key] = bcd2int(group[key])

        dtime = datetime(2000+group['year'], group['month'], group['day'], group['hour'], group['minute'], group['second'])

        for i, rec in enumerate(group['data']): 

            stat0 = decode_stat0(rec['stat0'])

            # reassemble the record in a more practical format
            rec = {
                    'groupno'  : group['groupno'],
                    'id'       : i,
                    'sampling' : group['sampling'],
                    'date'      : dtime.date(),
                    'time'      : dtime.time(),
                    #'value'    : stat1['sign'] * (100*rec['datH'] + rec['datL']) * stat0['Frange'],
                    'value'    : (100*rec['datH'] + rec['datL']) * stat0['Frange'],
                    'unit'     : stat0['unit'],
                    'range'    : stat0['range'],
                    'mode'     : stat0['mode'],
                    'hold'     : stat0['hold'],
                    'APO'      : stat0['APO']
                    }

            logger.append(rec)
            dtime += timedelta(seconds=group['sampling'])

    return(logger)


def logger_data2csv(dat):
    "returns csv from logger data list"

    cols = ('groupno', 'id', 'date', 'time', 'value', 'unit', 'range', 'mode', 'hold', 'APO')
    csv = [args.sep.join(cols)]
    for rec in dat:
        csv.append(args.sep.join(([str(rec[col]) for col in cols])))
    
    return("\n".join(csv))


def decode_stat0(byte):
    "return a dict from stat0 byte data"
    
    Stat0 = BitStruct(
                'APO'   / Flag,
                'hold'  / Flag,
                'mode'  / BitsInteger(3),
                'unit'  / Flag,
                'range' / BitsInteger(2)
            )
    ret = Stat0.parse(bytes([byte]))

    # I know this looks wrong but that's how they implemented the range order...
    Range = {
            'lux' : ('400k', '400',  '4k', '40k' ),
            'fc'  : ( '40k',  '40', '400',  '4k' )
            }
    
    mode = {
            0b000 : 'normal',
            0b010 : 'Pmin',
            0b011 : 'Pmax',
            0b100 : 'max',
            0b101 : 'min',
            0b110 : 'rel'
            }

    # factor to set decimal point depending on range
    Frange = {
            '40'   : 0.01,
            '400'  : 0.1,
            '4k'   : 1.0,
            '40k'  : 10,
            '400k' : 100
            }

    ret['unit'] = ('lux', 'fc')[ret['unit']]
    ret['range'] = Range[ret['unit']][ret['range']]
    ret['APO'] = ('on', 'off')[ret['APO']]
    ret['mode'] = mode[ret['mode']]
    ret['hold'] = ('cont', 'hold')[ret['hold']]
    ret['Frange'] = Frange[ret['range']]

    return(ret)


def decode_stat1(byte):
    "return a dict from Stat1 byte data"
    
    Stat1 = BitStruct(
                BitsInteger(2),
                'power'    / Flag,
                'sign'     / Flag,
                'dispmode' / BitsInteger(2),
                'memload'  / BitsInteger(2)
            )
    
    ret = Stat1.parse(bytes([byte]))
    
    dispmode = {
            0b00 : 'time',
            0b01 : 'day',
            0b10 : 'sampling',
            0b11 : 'year',
            }

    memload = {
            0b00 : None,
            0b01 : 'mem',
            0b10 : 'load',
            0b11 : None
            }

    ret['power'] = ('ok', 'low')[ret['power']]
    ret['sign'] = (1, -1)[ret['sign']]
    ret['dispmode'] = dispmode[ret['dispmode']]
    ret['memload'] = memload[ret['memload']]

    return(ret)


# command definition
cmd = OrderedDict([
    ('units', { 
        'cmd' : b"\xfe",	# command byte
        'ret' : False,		# will data be returned?
        'key' : 'UNITS',        # Equivalent key press
        'desc': "Toggle units between lux and fc"	# description
        }
        ),
    ('light', { 
        'cmd' : b"\xfd", 
        'ret' : False,
        'key' : 'Light/LOAD',
        'desc': "Toggle backlight"
        }
        ),
    ('range', { 
        'cmd' : b"\x7f", 
        'ret' : False,
        'key' : 'RANGE/APO',
        'desc': "Cycle through measurement ranges"
        }
        ),
    ('save', { 
        'cmd' : b"\xfb", 
        'ret' : False,
        'key' : 'REC/Setup',
        'desc': "Save reading to memory"
        }
        ),
    ('peak', { 
        'cmd' : b"\xf7", 
        'ret' : False,
        'key' : 'PEAK/LEFT',
        'desc': "Toggle peak value display"
        }
        ),
    ('rel', { 
        'cmd' : b"\xdf", 
        'ret' : False,
        'key' : 'REL/RIGHT',
        'desc': "Toggle realtive reading"
        }
        ),
    ('minmax', { 
        'cmd' : b"\xbf", 
        'ret' : False,
        'key' : 'MAX/MIN/UP',
        'desc': "Toggle Min/Max/current value display "
        }
        ),
    ('hold', { 
        'cmd' : b"\xef", 
        'ret' : False,
        'key' : 'HOLD/DOWN',
        'desc': "Toggle hold"
        }
        ),
    ('off', { 
        'cmd' : b"\xf3", 
        'ret' : False,
        'key' : 'POWER',
        'desc': "Turn off the instrument"
        }
        ),
    ('logging', { 
        'cmd' : b"\xdc", 
        'ret' : False,
        'key' : 'REC-hold',
        'desc': "Start/stop data logging"
        }
        ),
    ('prevview', { 
        'cmd' : b"\xda", 
        'ret' : False,
        'key' : 'PEAK-hold',
        'desc': "Switch to previous display view mode"
        }
        ),
    ('nextview', { 
        'cmd' : b"\xdb", 
        'ret' : False,
        'key' : 'REL-hold',
        'desc': "Switch to next display view mode"
        }
        ),
    ('viewsaved', { 
        'cmd' : b"\xde", 
        'ret' : False,
        'key' : 'LIGHT/LOAD-hold',
        'desc': "Toggle view mode for saved data"
        }
        ),
    ('get-live-data', { 
        'cmd' : b"\x11", 
        'ret' : True,
        'key' : None,
        'desc': "Read live data"
        }
        ),
    ('get-saved-data', { 
        'cmd' : b"\x12", 
        'ret' : True,
        'key' : None,
        'desc': "Read manually saved data (registers 1-99)"
        }
        ),
    ('get-logger-data', { 
        'cmd' : b"\x13", 
        'ret' : True,
        'key' : None,
        'desc': "Read logger data"
        }
        )
    ])


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass

# EOF
