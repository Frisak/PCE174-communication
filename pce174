#!/usr/bin/env python3
"""
pce174 - a little tool to communicate with a PCE-174 lightmeter/logger
"""

# todo
#   - fix decoder for status information stat1
#   - double check the renage levels and factors: doe they really differ frtom the docs?
#   - find out how to handle signed/unsigned measurements
#   - implement get-logger-data
#   - implement get-timing
#   - implement logging interval setting
#   - find out how to send simultaneous key presses (if possible)
#   - find out if we can set date, time and sampling interval through a command
#   - test, test, test


import sys, argparse
import serial
import binascii
# requires construct â‰¥ 2.8 (tested with 2.9)
from construct import * 


def main():
    "The main function - duh."

    args = getargs()

    if args.list:
        print("Available commands:")
        for key, value in cmd.items():
            print("\t", key)
    elif args.command in cmd:
        try:
            iface = serial.Serial(args.interface, args.baud, timeout=5)
        except:
            sys.exit("Unable to connect to device.") 
        hello = b"\x87\x83"	# command prefix
        msg = hello + cmd[args.command]['cmd']
        iface.write(msg)
        if cmd[args.command]['ret']: # read data
            blob = iface.read(100000)
            if args.format == "raw":
                sys.stdout.buffer.write(blob)
            elif args.format == "hex":
                sys.stdout.buffer.write(binascii.hexlify(blob))
            elif args.format == "csv":
                print(decode_blob(blob))
        iface.close()


def getargs():
    "Get commandline options and arguments"

    parser = argparse.ArgumentParser(description="Talk to a PCE-174 lightmeter/logger")

    parser.add_argument('-l', '--list', dest='list', action='store_true', help="List all available commands")
    parser.add_argument('-i', dest="interface", type=str, default='/dev/ttyUSB0', help="interface to connect to (/dev/ttyUSB0)")
    parser.add_argument('-b', dest="baud", type=int, default=9600, help="baudrate (9600)")
    parser.add_argument('-f', dest="format", type=str, default="csv", choices=['csv','raw','hex'], 
            help="return data in the specified format (csv)"
            )
    parser.add_argument('command', nargs='?', type=str, help="command to send to instrument")

    return(parser.parse_args())


def bcd2int(dat):
    "Return the decimal value of a BCD encoded int"

    ret = 0
    f = 1
    while dat != 0:
        val = dat & 0x0f
        if val > 9:
            sys.exit("Illegal tetrade encountered in BCD conversion.")
        ret += f * val
        f *= 10
        dat = dat >> 4
    return(ret)


def decode_blob(blob):
    "return decoded data"

    ret = None
    cmdid = blob[:2]
    blob = blob[2:]

    if cmdid == b"\xbb\x88":
        ret = decode_stored_data(blob)
    elif cmdid == b"\xaa\xdd":
        ret = decode_timing_data(blob)
    elif cmdid == b"\xaa\xcc":
        ret = decode_logger_data(blob)
    elif cmdid == b"\xaa\x56":
        logger_data = Struct(
                'group'     / Int8ub('group'),
                'sampling'  / Int8ub('sampling'),
                Padding(1),
                'year'      / Int8ub('year'),
                'week'      / Int8ub('week'),
                'month'     / Int8ub('month'),
                'day'       / Int8ub('day'),
                'hour'      / Int8ub('hour'),
                'minute'    / Int8ub('minute'),
                'second'    / Int8ub('second'),
                'datH'      / Int8ub('second'),
                'datL'      / Int8ub('second'),
                'stat0'     / Int8ub('stat0')
                )
        ret = logger_data.parse(blob)
    else:
        raise Exception('Unknown command ID in received data')

    return(ret)


def decode_stored_data(blob):
    "Decode the stored_data binary blob to CSV"

    record = Struct(
            Padding(1),
            'year'  / Int8ub,
            'week'  / Int8ub,
            'month' / Int8ub,
            'day'   / Int8ub,
            'hour'  / Int8ub,
            'minute'/ Int8ub,
            'second'/ Int8ub,
            'pos'   / Int8ub,
            'datH'  / Int8ub,
            'datL'  / Int8ub,
            'stat0' / Int8ub,
            'stat1' / Int8ub
           )

    mode = {
            0b000 : 'normal',
            0b010 : 'Pmin',
            0b011 : 'Pmax',
            0b100 : 'max',
            0b101 : 'min',
            0b110 : 'rel'
            }

    dispmode = {
            0b00 : 'time',
            0b01 : 'day',
            0b10 : 'sampling',
            0b11 : 'year',
            }

    memload = {
            0b01 : 'mem',
            0b10 : 'load'
            }


    db = GreedyRange(record)
    dat = db.parse(blob)

    cols = ('pos', 'date', 'time', 'value', 'unit', 'range', 'mode', 'hold', 'APO', 'powerlow', 'signed', 'dispmode', 'memload', 'stat0', 'stat1')
    ret = [", ".join(cols)]

    for rec in dat:
        for key in ['year', 'week', 'month', 'day', 'hour', 'minute', 'second']:
            rec[key] = bcd2int(rec[key])
        rec['year'] += 2000

        # reassemble the record in a more practical format
        stat0 = decode_stat0(rec['stat0'])
        stat1 = decode_stat1(rec['stat1'])

        rec = {
                'pos'  : rec['pos'],
                'date' : "%4.4i-%2.2i-%2.2i" % (rec['year'], rec['month'], rec['day']),
                'time' : "%2.2i:%2.2i:%2.2i" % (rec['hour'], rec['minute'], rec['second']),
                'value': (100*rec['datH'] + rec['datL']) * (100,0.1,1,10)[stat0['range']],
                'stat0': rec['stat0'],
                'APO'  : not stat0['APO'],
                'hold' : stat0['hold'],
                'unit' : ('lux', 'fc')[stat0['unit']],
                'range': (3, 0, 1, 2)[stat0['range']],
                'mode' : mode[stat0['mode']],
                'powerlow': stat1['powerlow'],
                'signed'  : stat1['signed'],
                'dispmode': dispmode[stat1['dispmode']],
                'memload': stat1['memload'],
                'stat0': bin(rec['stat0']),
                'stat1': bin(rec['stat1'])
                }
       
        # turn rec into a comma separated row
        if rec['pos'] > 0:
            ret.append(", ".join(([str(rec[col]) for col in cols])))

    return("\n".join(ret))


def decode_logger_data(blob):
    "Decode the logger_data binary blob to csv"

    logger_buffer = Struct(
            'groups'     / Int8ub,
            'buffersize' / Int16ub
            )
    ret = logger_buffer.parse(blob)


def decode_timing_data(blob):
    "Decode the timing binary blob to csv"

    timing_data = Struct(
            Padding(1),
            'year'    / Int8ub,
            'week'    / Int8ub,
            'month'   / Int8ub,
            'day'     / Int8ub,
            'hour'    / Int8ub,
            'minute'  / Int8ub,
            'second'  / Int8ub,
            'datH'    / Int8ub,
            'datL'    / Int8ub,
            'stat0'   / Int8ub,
            'stat1'   / Int8ub,
            'mem_no'  / Int8ub,
            'read_no' / Int8ub
            )
    ret = timing_data.parse(blob)


def decode_stat0(byte):
    "return a dict from stat0 byte data"
    
    stat0 = BitStruct(
                'APO' / Flag,
                'hold' / Flag,
                'mode' / BitsInteger(3),
                'unit' / Flag,
                'range' / BitsInteger(2)
            )
    ret = stat0.parse(bytes([byte]))

    return(ret)


def decode_stat1(byte):
    "return a dict from stat1 byte data"
    
    stat1 = BitStruct(
                BitsInteger(2),
                'powerlow' / Flag,
                'signed' / Flag,
                'dispmode' / BitsInteger(2),
                'memload' / BitsInteger(2)
            )
    ret = stat1.parse(bytes([byte]))

    return(ret)


# command definition
cmd = {
        'units' : { 
            'cmd' : b"\xfe",		# command byte
            'ret' : False,		# will data be returned?
            'desc': "Toggle units between lux and foot candle (fc)"	# description
            },
        'light' : { 
            'cmd' : b"\xfd", 
            'ret' : False,
            'desc': "Toggle backlight"
            },
        'save' : { 
            'cmd' : b"\xfb", 
            'ret' : False,
            'desc': "Mem/setup"
            },
        'peak' : { 
            'cmd' : b"\xf7", 
            'ret' : False,
            'desc': "Toggle peak value display"
            },
        'rel' : { 
            'cmd' : b"\xdf", 
            'ret' : False,
            'desc': "Toggle realtive reading"
            },
        'hold' : { 
            'cmd' : b"\xef", 
            'ret' : False,
            'desc': "Toggle value hold"
            },
        'minmax' : { 
            'cmd' : b"\xbf", 
            'ret' : False,
            'desc': "Toggle Min/Max/current value discplay "
            },
        'logger' : { 
            'cmd' : b"\xdc", 
            'ret' : False,
            'desc': "??? Data logger hold REC"
            },
        'relhold' : { 
            'cmd' : b"\xdb", 
            'ret' : False,
            'desc': ""
            },
        'lighthold' : { 
            'cmd' : b"\xde", 
            'ret' : False,
            'desc': "???"
            },
        'peakhold' : { 
            'cmd' : b"\xda", 
            'ret' : False,
            'desc': "???"
            },
        'range' : { 
            'cmd' : b"\x7f", 
            'ret' : False,
            'desc': "Cycle through measurement ranges"
            },
        'off' : { 
            'cmd' : b"\xf3", 
            'ret' : False,
            'desc': "Turn off the instrument"
            },
        'get-timing' : { 
            'cmd' : b"\x11", 
            'ret' : True,
            'desc': "Timing data transmit"
            },
        'get-stored-data' : { 
            'cmd' : b"\x12", 
            'ret' : True,
            'desc': "Read stored data"
            },
        'get-logger-data' : { 
            'cmd' : b"\x13", 
            'ret' : True,
            'desc': "Read logger data"
            },
        'get-data-protocol' : { 
            'cmd' : b"\x14", 
            'ret' : True,
            'desc': "Data logger data transmit protocol"
            }
        }


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass

# EOF
