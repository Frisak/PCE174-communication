#!/usr/bin/env python3
"""
pce174 - a little tool to communicate with a PCE-174 lightmeter/logger
"""

# todo
#   - fix decoder for status information stat1 (memload translation non functional)
#   - implement get-logger-data
#   - implement get-timing
#   - implement logging interval setting
#   - find out how to send simultaneous key presses (if possible)
#   - find out if we can set date, time and sampling interval through a command
#   - improve -l output
#   - test, test, test


import sys, argparse
import serial
import warnings
import binascii
# requires construct â‰¥ 2.8 (tested with 2.9)
from construct import * 


def main():
    "The main function - duh."

    args = getargs()

    if args.list:
        print("Available commands:")
        for key, value in cmd.items():
            print("\t", key)
    elif args.command in cmd:
        try:
            iface = serial.Serial(args.interface, args.baud, timeout=5)
        except:
            sys.exit("Unable to connect to device.") 

        hello = b"\x87\x83"	# command prefix
        msg = hello + cmd[args.command]['cmd']
        iface.write(msg)
        if cmd[args.command]['ret']: # read data
            blob = iface.read(100000)
            if args.format == "raw":
                sys.stdout.buffer.write(blob)
            elif args.format == "hex":
                sys.stdout.buffer.write(binascii.hexlify(blob))
            elif args.format == "csv":
                print(decode_blob(blob))
        iface.close()


def getargs():
    "Return commandline options and arguments"

    parser = argparse.ArgumentParser(description="Talk to a PCE-174 lightmeter/logger")

    parser.add_argument('-l', '--list', dest='list', action='store_true', help="List all available commands")
    parser.add_argument('-i', dest="interface", type=str, default='/dev/ttyUSB0', help="interface to connect to (/dev/ttyUSB0)")
    parser.add_argument('-b', dest="baud", type=int, default=9600, help="baudrate (9600)")
    parser.add_argument('-f', dest="format", type=str, default="csv", choices=['csv','raw','hex'], 
            help="return data in the specified format (csv)"
            )
    parser.add_argument('command', nargs='?', type=str, help="command to send to instrument")

    return(parser.parse_args())


def bcd2int(dat):
    "Return the decimal value of a BCD encoded int"

    ret = 0
    f = 1
    while dat != 0:
        val = dat & 0x0f
        if val > 9:
            warnings.warn("Pseudo-tetrade encountered in BCD conversion.")
        ret += f * val
        f *= 10
        dat = dat >> 4
    return(ret)


def decode_blob(blob):
    "return decoded data"

    ret = None
    cmdid = blob[:2]
    blob = blob[2:]

    if cmdid == b"\xbb\x88":
        ret = decode_stored_data(blob)
    elif cmdid == b"\xaa\xdd":
        ret = decode_timing_data(blob)
    elif cmdid == b"\xaa\xcc":
        ret = decode_logger_data(blob)
    elif cmdid == b"\xaa\x56":
        logger_data = Struct(
                'group'     / Int8ub('group'),
                'sampling'  / Int8ub('sampling'),
                Padding(1),
                'year'      / Int8ub('year'),
                'week'      / Int8ub('week'),
                'month'     / Int8ub('month'),
                'day'       / Int8ub('day'),
                'hour'      / Int8ub('hour'),
                'minute'    / Int8ub('minute'),
                'second'    / Int8ub('second'),
                'datH'      / Int8ub('second'),
                'datL'      / Int8ub('second'),
                'stat0'     / Int8ub('stat0')
                )
        ret = logger_data.parse(blob)
    else:
        raise Exception('Unknown command ID in received data')

    return(ret)


def decode_stored_data(blob):
    "Decode the stored_data binary blob to CSV"

    record = Struct(
            Padding(1),
            'year'  / Int8ub,
            'week'  / Int8ub,
            'month' / Int8ub,
            'day'   / Int8ub,
            'hour'  / Int8ub,
            'minute'/ Int8ub,
            'second'/ Int8ub,
            'pos'   / Int8ub,
            'datH'  / Int8ub,
            'datL'  / Int8ub,
            'stat0' / Int8ub,
            'stat1' / Int8ub
           )

    # factor to set decimal point depending on range
    Flevel = {
            '40'   : 0.01,
            '400'  : 0.1,
            '4k'   : 1.0,
            '40k'  : 10,
            '400k' : 100
            }

    db = GreedyRange(record)
    dat = db.parse(blob)

    # define columns and assemble header
    cols = ('pos', 'date', 'time', 'value', 'unit', 'range', 'mode', 'hold', 'APO', 'power', 'dispmode', 'memload')
    ret = [", ".join(cols)]

    for rec in dat:
        # turn bcd encoded variables into ints
        for key in ['year', 'week', 'month', 'day', 'hour', 'minute', 'second']:
            rec[key] = bcd2int(rec[key])

        rec['year'] += 2000
 
        # decode the stat bytes
        stat0 = decode_stat0(rec['stat0'])
        stat1 = decode_stat1(rec['stat1'])

        # reassemble the record in a more practical format
        rec = {
                'pos'      : rec['pos'],
                'date'     : "%4.4i-%2.2i-%2.2i" % (rec['year'], rec['month'], rec['day']),
                'time'     : "%2.2i:%2.2i:%2.2i" % (rec['hour'], rec['minute'], rec['second']),
                'value'    : stat1['sign'] * (100*rec['datH'] + rec['datL']) * Flevel[stat0['range']],
                'APO'      : stat0['APO'],
                'hold'     : stat0['hold'],
                'unit'     : stat0['unit'],
                'range'    : stat0['range'],
                'mode'     : stat0['mode'],
                'power'    : stat1['power'],
                'dispmode' : stat1['dispmode'],
                'memload'  : stat1['memload']
                }
       
        # turn rec into a comma separated row
        if rec['pos'] > 0:
            ret.append(", ".join(([str(rec[col]) for col in cols])))

    return("\n".join(ret))


def decode_logger_data(blob):
    "Decode the logger_data binary blob to csv"

    logger_buffer = Struct(
            'groups'     / Int8ub,
            'buffersize' / Int16ub
            )
    ret = logger_buffer.parse(blob)


def decode_timing_data(blob):
    "Decode the timing binary blob to csv"

    timing_data = Struct(
            Padding(1),
            'year'    / Int8ub,
            'week'    / Int8ub,
            'month'   / Int8ub,
            'day'     / Int8ub,
            'hour'    / Int8ub,
            'minute'  / Int8ub,
            'second'  / Int8ub,
            'datH'    / Int8ub,
            'datL'    / Int8ub,
            'stat0'   / Int8ub,
            'stat1'   / Int8ub,
            'mem_no'  / Int8ub,
            'read_no' / Int8ub
            )
    ret = timing_data.parse(blob)


def decode_stat0(byte):
    "return a dict from stat0 byte data"
    
    stat0 = BitStruct(
                'APO'   / Flag,
                'hold'  / Flag,
                'mode'  / BitsInteger(3),
                'unit'  / Flag,
                'range' / BitsInteger(2)
            )
    ret = stat0.parse(bytes([byte]))

    Range = {   # yes, this looks wrong but it is correct.
            'lux' : ('400k', '400',  '4k', '40k' ),
            'fc'  : ( '40k',  '40', '400',  '4k' )
            }
    
    mode = {
            0b000 : 'normal',
            0b010 : 'Pmin',
            0b011 : 'Pmax',
            0b100 : 'max',
            0b101 : 'min',
            0b110 : 'rel'
            }

    ret['unit'] = ('lux', 'fc')[ret['unit']]
    ret['range'] = Range[ret['unit']][ret['range']]
    ret['APO'] = ('on', 'off')[ret['APO']]
    ret['mode'] = mode[ret['mode']]
    ret['hold'] = ('cont', 'hold')[ret['hold']]
    
    return(ret)


def decode_stat1(byte):
    "return a dict from stat1 byte data"
    
    Stat1 = BitStruct(
                BitsInteger(2),
                'power'    / Flag,
                'sign'     / Flag,
                'dispmode' / BitsInteger(2),
                'memload'  / BitsInteger(2)
            )
    
    ret = Stat1.parse(bytes([byte]))
    
    dispmode = {
            0b00 : 'time',
            0b01 : 'day',
            0b10 : 'sampling',
            0b11 : 'year',
            }

    memload = {
            0b01 : 'mem',
            0b10 : 'load'
            }

    ret['dispmode'] = dispmode[ret['dispmode']]
    ret['sign'] = (1, -1)[ret['sign']]
    ret['power'] = ('ok', 'low')[ret['power']]
    #ret['memload'] = memload[ret['memload']]

    return(ret)


# command definition
cmd = {
        'units' : { 
            'cmd' : b"\xfe",		# command byte
            'ret' : False,		# will data be returned?
            'desc': "Toggle units between lux and foot candle (fc)"	# description
            },
        'light' : { 
            'cmd' : b"\xfd", 
            'ret' : False,
            'desc': "Toggle backlight"
            },
        'save' : { 
            'cmd' : b"\xfb", 
            'ret' : False,
            'desc': "Save reading to memory"
            },
        'peak' : { 
            'cmd' : b"\xf7", 
            'ret' : False,
            'desc': "Toggle peak value display"
            },
        'rel' : { 
            'cmd' : b"\xdf", 
            'ret' : False,
            'desc': "Toggle realtive reading"
            },
        'hold' : { 
            'cmd' : b"\xef", 
            'ret' : False,
            'desc': "Toggle value hold"
            },
        'minmax' : { 
            'cmd' : b"\xbf", 
            'ret' : False,
            'desc': "Toggle Min/Max/current value discplay "
            },
        'logger' : { 
            'cmd' : b"\xdc", 
            'ret' : False,
            'desc': "Start/stop data logging"
            },
        'relhold' : { 
            'cmd' : b"\xdb", 
            'ret' : False,
            'desc': "Switch to next display mode"
            },
        'lighthold' : { 
            'cmd' : b"\xde", 
            'ret' : False,
            'desc': "Toggle view mode for saved data"
            },
        'peakhold' : { 
            'cmd' : b"\xda", 
            'ret' : False,
            'desc': "Switch to previous display mode"
            },
        'range' : { 
            'cmd' : b"\x7f", 
            'ret' : False,
            'desc': "Cycle through measurement ranges"
            },
        'off' : { 
            'cmd' : b"\xf3", 
            'ret' : False,
            'desc': "Turn off the instrument"
            },
        'get-timing' : { 
            'cmd' : b"\x11", 
            'ret' : True,
            'desc': "Timing data transmit"
            },
        'get-stored-data' : { 
            'cmd' : b"\x12", 
            'ret' : True,
            'desc': "Read stored data"
            },
        'get-logger-data' : { 
            'cmd' : b"\x13", 
            'ret' : True,
            'desc': "Read logger data"
            },
        'get-data-protocol' : { 
            'cmd' : b"\x14", 
            'ret' : True,
            'desc': "Data logger data transmit protocol"
            }
        }


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass

# EOF
