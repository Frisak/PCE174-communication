#!/usr/bin/env python3
"""
pce174 

A tool to communicate with a PCE-174 lightmeter/logger
"""

# todo
#   - implement get-logger-data
#   - what is memload? is this a usefull name?
#   - what is read_no in live data?
#   - find out how to send simultaneous key presses (if possible)
#   - find out if we can set date, time and sampling interval through a command
#   - maybe round output or asseble values in BCD to avoid funny numrical artifacts?
#   - try: does the instrument sen ACK after commands? or error codes?
#   - detect unknown commands and warn
#   - test, test, test


import sys, argparse
import serial
import warnings
import binascii
from collections import OrderedDict
# requires construct â‰¥ 2.8 (tested with 2.9)
from construct import * 


def main():
    "The main function - duh."

    args = getargs()

    if args.list:
        print("Available commands:\n")
        for key, value in cmd.items():
            print(" ", key)
            print(' '*5, value['desc'])
            print(' '*5, "Button:", value['key'])
            if value['ret']:
                print(' '*5, "Returns data in the specified format (-f)")
            print()
    elif args.command in cmd:
        try:
            iface = serial.Serial(args.interface, args.baud, timeout=args.timeout)
        except:
            sys.exit("Unable to connect to device.") 

        hello = b"\x87\x83"	# command prefix
        msg = hello + cmd[args.command]['cmd']
        iface.write(msg)
        if cmd[args.command]['ret']: # read data
            blob = iface.read(100000)
            if args.format == "raw":
                sys.stdout.buffer.write(blob)
            elif args.format == "hex":
                sys.stdout.buffer.write(binascii.hexlify(blob))
            elif args.format == "csv":
                print(decode_blob(args.command, blob))
        iface.close()
    else:
        sys.exit("Unknown command")

def getargs():
    "Return commandline options and arguments"

    parser = argparse.ArgumentParser(description="Talk to a PCE-174 lightmeter/logger")

    parser.add_argument('-l', '--list', dest='list', action='store_true', help="list all available commands")
    parser.add_argument('-i', dest="interface", type=str, default='/dev/ttyUSB0', help="interface to connect to (/dev/ttyUSB0)")
    parser.add_argument('-b', dest="baud", type=int, default=9600, help="baudrate (9600)")
    parser.add_argument('-t', dest="timeout", type=float, default=3, help="serial communication timeout [s] (3)")
    parser.add_argument('-f', dest="format", type=str, default="csv", choices=['csv','raw','hex'], 
            help="return data in the specified format (csv)"
            )
    parser.add_argument('command', nargs='?', type=str, help="command to send to instrument")

    return(parser.parse_args())


def bcd2int(dat):
    "Return the decimal value of a BCD encoded int"

    ret = 0
    f = 1
    while dat != 0:
        val = dat & 0x0f
        if val > 9:
            warnings.warn("Pseudo-tetrade encountered in BCD conversion.")
        ret += f * val
        f *= 10
        dat = dat >> 4
    return(ret)


def decode_blob(cmd, blob):
    "return decoded data"

    ret = None
    if cmd == "get-live-data":
        ret = decode_live_data(blob)
    elif cmd == "get-saved-data":
        ret = decode_saved_data(blob)
    elif cmd == "get-logger-data":
        ret = decode_logger_data(blob)
    else:
        raise Exception('Unknown command ID in received data')

    return(ret)


def decode_live_data(blob):
    "Decode live data to csv"

    Live_data = Struct(
            'magic' / Const(b'\xaa\xdd'),
            Padding(1),
            'year'    / Int8ub,
            'weekday' / Int8ub,
            'month'   / Int8ub,
            'day'     / Int8ub,
            'hour'    / Int8ub,
            'minute'  / Int8ub,
            'second'  / Int8ub,
            'dat0H'   / Int8ub,
            'dat0L'   / Int8ub,
            'dat1H'   / Int8ub,
            'dat1L'   / Int8ub,
            'stat0'   / Int8ub,
            'stat1'   / Int8ub,
            'mem_no'  / Int8ub,
            'read_no' / Int8ub
            )

    rec = Live_data.parse(blob)

    # define columns and assemble header
    cols = ('date', 'time', 'value', 'rawvalue', 'unit', 'range', 'mode', 'hold', 'APO', 'power', 'dispmode', 'memload', 'mem_no', 'read_no')
    ret = [", ".join(cols)]

    # bcd decoding
    for key in ['year', 'weekday', 'month', 'day', 'hour', 'minute', 'second']:
        rec[key] = bcd2int(rec[key])

    stat0 = decode_stat0(rec['stat0'])
    stat1 = decode_stat1(rec['stat1'])

    # reassemble the record in a more practical format
    rec = {
            'date'     : "20%2.2i-%2.2i-%2.2i" % (rec['year'], rec['month'], rec['day']),
            'time'     : "%2.2i:%2.2i:%2.2i" % (rec['hour'], rec['minute'], rec['second']),
            'value'    : stat1['sign'] * (100*rec['dat1H'] + rec['dat1L']) * stat0['Frange'],
            'rawvalue' : (100*rec['dat0H'] + rec['dat0L']) * stat0['Frange'],
            'APO'      : stat0['APO'],
            'hold'     : stat0['hold'],
            'unit'     : stat0['unit'],
            'range'    : stat0['range'],
            'mode'     : stat0['mode'],
            'power'    : stat1['power'],
            'dispmode' : stat1['dispmode'],
            'memload'  : stat1['memload'],
            'mem_no'   : rec['mem_no'],
            'read_no'  : rec['read_no']
            }

    # turn rec into a comma separated row
    ret.append(", ".join(([str(rec[col]) for col in cols])))

    #return(ret)
    return("\n".join(ret))


def decode_saved_data(blob):
    "Decode stored-data to CSV"

    record = Struct(
            'foo'   / Int8ub, # should be 0x00 but isn't always
            #'magic' / Const(b'\x00'),
            'year'  / Int8ub,
            'week'  / Int8ub,
            'month' / Int8ub,
            'day'   / Int8ub,
            'hour'  / Int8ub,
            'minute'/ Int8ub,
            'second'/ Int8ub,
            'pos'   / Int8ub,
            'datH'  / Int8ub,
            'datL'  / Int8ub,
            'stat0' / Int8ub,
            'stat1' / Int8ub
           )

    db = Struct(
            'magic' / Const(b'\xbb\x88'),
            'data'  / Array(99, record)
            )
    
    dat = db.parse(blob)

    # define columns and assemble header
    cols = ('pos', 'date', 'time', 'value', 'unit', 'range', 'mode', 'hold', 'APO', 'power', 'dispmode', 'memload')
    ret = [", ".join(cols)]

    for rec in dat['data']:
        # bcd decoding
        for key in ['year', 'week', 'month', 'day', 'hour', 'minute', 'second']:
            rec[key] = bcd2int(rec[key])

        stat0 = decode_stat0(rec['stat0'])
        stat1 = decode_stat1(rec['stat1'])

        # reassemble the record in a more practical format
        rec = {
                'pos'      : rec['pos'],
                'date'     : "20%2.2i-%2.2i-%2.2i" % (rec['year'], rec['month'], rec['day']),
                'time'     : "%2.2i:%2.2i:%2.2i" % (rec['hour'], rec['minute'], rec['second']),
                'value'    : stat1['sign'] * (100*rec['datH'] + rec['datL']) * stat0['Frange'],
                'APO'      : stat0['APO'],
                'hold'     : stat0['hold'],
                'unit'     : stat0['unit'],
                'range'    : stat0['range'],
                'mode'     : stat0['mode'],
                'power'    : stat1['power'],
                'dispmode' : stat1['dispmode'],
                'memload'  : stat1['memload']
                }
       
        # turn rec into a comma separated row
        if rec['pos'] > 0:
            ret.append(", ".join(([str(rec[col]) for col in cols])))

    return("\n".join(ret))


def decode_logger_data(blob):
    "Decode logger_data to csv"


    Datapoint = Struct(
            'datH'  / Int8ub,
            'datL'  / Int8ub,
            'stat0' / Int8ub
            )

    Record = Struct(
            'magic'     / Const(b'\xaa\x56'),
            'recno'     / Int8ub,
            'sampling'  / Int8ub,
            'reserved'  / Const(b'\x00\x00'),
            'year'      / Int8ub,
            'weekday'   / Int8ub,
            'month'     / Int8ub,
            'day'       / Int8ub,
            'hour'      / Int8ub,
            'minute'    / Int8ub,
            'second'    / Int8ub,
            'data'      / Array(this.recno, Datapoint) # this is not right - but what is?
            )

    db = Struct(
            'magic'   / Const(b'\xaa\xcc'),
            'groups'  / Int8ub,
            'bufsize' / Int16ub,
            #'data'    / Array(this.groups, Record)
            'data'    / Record
            )
    # XXX Hm - how do I know how many data points are in a record?

    dat = db.parse(blob)

    return(dat)


def decode_stat0(byte):
    "return a dict from stat0 byte data"
    
    Stat0 = BitStruct(
                'APO'   / Flag,
                'hold'  / Flag,
                'mode'  / BitsInteger(3),
                'unit'  / Flag,
                'range' / BitsInteger(2)
            )
    ret = Stat0.parse(bytes([byte]))

    # I know this looks wrong but that's how they implemented the range order...
    Range = {
            'lux' : ('400k', '400',  '4k', '40k' ),
            'fc'  : ( '40k',  '40', '400',  '4k' )
            }
    
    mode = {
            0b000 : 'normal',
            0b010 : 'Pmin',
            0b011 : 'Pmax',
            0b100 : 'max',
            0b101 : 'min',
            0b110 : 'rel'
            }

    # factor to set decimal point depending on range
    Frange = {
            '40'   : 0.01,
            '400'  : 0.1,
            '4k'   : 1.0,
            '40k'  : 10,
            '400k' : 100
            }

    ret['unit'] = ('lux', 'fc')[ret['unit']]
    ret['range'] = Range[ret['unit']][ret['range']]
    ret['APO'] = ('on', 'off')[ret['APO']]
    ret['mode'] = mode[ret['mode']]
    ret['hold'] = ('cont', 'hold')[ret['hold']]
    ret['Frange'] = Frange[ret['range']]

    return(ret)


def decode_stat1(byte):
    "return a dict from Stat1 byte data"
    
    Stat1 = BitStruct(
                BitsInteger(2),
                'power'    / Flag,
                'sign'     / Flag,
                'dispmode' / BitsInteger(2),
                'memload'  / BitsInteger(2)
            )
    
    ret = Stat1.parse(bytes([byte]))
    
    dispmode = {
            0b00 : 'time',
            0b01 : 'day',
            0b10 : 'sampling',
            0b11 : 'year',
            }

    memload = {
            0b00 : None,
            0b01 : 'mem',
            0b10 : 'load',
            0b11 : None
            }

    ret['power'] = ('ok', 'low')[ret['power']]
    ret['sign'] = (1, -1)[ret['sign']]
    ret['dispmode'] = dispmode[ret['dispmode']]
    ret['memload'] = memload[ret['memload']]

    return(ret)


# command definition
cmd = OrderedDict([
    ('units', { 
        'cmd' : b"\xfe",		# command byte
        'ret' : False,		# will data be returned?
        'key' : 'UNITS',            # Equivalent key press
        'desc': "Toggle units between lux and fc"	# description
        }
        ),
    ('light', { 
        'cmd' : b"\xfd", 
        'ret' : False,
        'key' : 'Light/LOAD',
        'desc': "Toggle backlight"
        }
        ),
    ('range', { 
        'cmd' : b"\x7f", 
        'ret' : False,
        'key' : 'RANGE/APO',
        'desc': "Cycle through measurement ranges"
        }
        ),
    ('save', { 
        'cmd' : b"\xfb", 
        'ret' : False,
        'key' : 'REC/Setup',
        'desc': "Save reading to memory"
        }
        ),
    ('peak', { 
        'cmd' : b"\xf7", 
        'ret' : False,
        'key' : 'PEAK/LEFT',
        'desc': "Toggle peak value display"
        }
        ),
    ('rel', { 
        'cmd' : b"\xdf", 
        'ret' : False,
        'key' : 'REL/RIGHT',
        'desc': "Toggle realtive reading"
        }
        ),
    ('minmax', { 
        'cmd' : b"\xbf", 
        'ret' : False,
        'key' : 'MAX/MIN/UP',
        'desc': "Toggle Min/Max/current value display "
        }
        ),
    ('hold', { 
        'cmd' : b"\xef", 
        'ret' : False,
        'key' : 'HOLD/DOWN',
        'desc': "Toggle hold"
        }
        ),
    ('off', { 
        'cmd' : b"\xf3", 
        'ret' : False,
        'key' : 'POWER',
        'desc': "Turn off the instrument"
        }
        ),
    ('logging', { 
        'cmd' : b"\xdc", 
        'ret' : False,
        'key' : 'REC-hold',
        'desc': "Start/stop data logging"
        }
        ),
    ('prevview', { 
        'cmd' : b"\xda", 
        'ret' : False,
        'key' : 'PEAK-hold',
        'desc': "Switch to previous display view mode"
        }
        ),
    ('nextview', { 
        'cmd' : b"\xdb", 
        'ret' : False,
        'key' : 'REL-hold',
        'desc': "Switch to next display view mode"
        }
        ),
    ('viewsaved', { 
        'cmd' : b"\xde", 
        'ret' : False,
        'key' : 'LIGHT/LOAD-hold',
        'desc': "Toggle view mode for saved data"
        }
        ),
    ('get-live-data', { 
        'cmd' : b"\x11", 
        'ret' : True,
        'key' : None,
        'desc': "Read live data."
        },
        ),
    ('get-saved-data', { 
        'cmd' : b"\x12", 
        'ret' : True,
        'key' : None,
        'desc': "Read manually saved data"
        }
        ),
    ('get-logger-data', { 
        'cmd' : b"\x13", 
        'ret' : True,
        'key' : None,
        'desc': "Read logger data"
        },
        )
    ])


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass

# EOF
