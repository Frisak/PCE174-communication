#!/usr/bin/env python3
"""
pce174 - a little tool to communicate with a PCE-174 lightmeter/logger
"""

# todo
#   - understand/decode value in stored-data record
#   - write decoder for status information
#   - implement get-logger-data
#   - implement get-timing
#   - implement logging interval setting
#   - test all commands!

import sys, argparse
import serial
import binascii

# tested with construct 2.5.5. The current versions (â‰¥ 2.8 semm to be incompatible!)
from construct import * 

def main():
    "The main function - duh."

    args = getargs()

    if args.list:
        print("Available commands:")
        for key, value in cmd.items():
            print("\t", key)
    elif args.command in cmd:
        iface = serial.Serial(args.interface, args.baud, timeout=5)
        hello = b"\x87\x83"	# command prefix
        msg = hello + cmd[args.command]['cmd']
        iface.write(msg)
        if cmd[args.command]['ret']: # read data
            blob = iface.read(100000)
            if args.format == "raw":
                sys.stdout.buffer.write(blob)
            elif args.format == "hex":
                sys.stdout.buffer.write(binascii.hexlify(blob))
            elif args.format == "csv":
                print(decode_blob(blob))
        iface.close()


def getargs():
    "Get commandline options and arguments"

    parser = argparse.ArgumentParser(description="Talk to a PCE-174 lightmeter/logger")

    parser.add_argument('-l', '--list', dest='list', action='store_true', help="List all available commands")
    parser.add_argument('-i', dest="interface", type=str, default='/dev/ttyUSB0', help="interface to connect to (/dev/ttyUSB0)")
    parser.add_argument('-b', dest="baud", type=int, default=9600, help="baudrate (9600)")
    parser.add_argument('-f', dest="format", type=str, default="csv", choices=['csv','raw','hex'], 
            help="return data in the specified format (csv)"
            )
    parser.add_argument('command', nargs='?', type=str, help="command to send to instrument")

    return(parser.parse_args())


def bcd2int(byte):
    "Return the decimal value of a BCD encoded byte"
    
    return(10 * (byte >> 4) + (byte & 0x0f))


def decode_blob(blob):
    """return decoded data
    """

    ret = None
    cmdid = blob[:2]
    blob = blob[2:]

    if cmdid == b"\xbb\x88":
        ret = decode_stored_data(blob)
    elif cmdid == b"\xaa\xdd":
        ret = decode_timing_data(blob)
    elif cmdid == b"\xaa\xcc":
        ret = decode_logger_data(blob)
    elif cmdid == b"\xaa\x56":
        logger_data = Struct(
            "data_logger tx protocol",
            UBInt8('group'),
            UBInt8('sampling'),
            Padding(1),
            UBInt8('year'),
            UBInt8('week'),
            UBInt8('month'),
            UBInt8('day'),
            UBInt8('hour'),
            UBInt8('minute'),
            UBInt8('second'),
            ULInt16('value'),
            UBInt8('stat0')
            )
        ret = logger_data.parse(blob)
    else:
        raise Exception('Unknown command ID in received data')

    return(ret)


def decode_stored_data(blob):
    "Decode the stored_data binary blob to CSV"

    record = Struct(
        Padding(1),
        'year'      / Int8ub,
        'week'      / Int8ub,
        'month'     / Int8ub,
        'day'       / Int8ub,
        'hour'      / Int8ub,
        'minute'    / Int8ub,
        'second'    / Int8ub,
        'value'     / Int16ul,
        'stat0'     / Int8ub,
        'stat1'     / Int8ub,
        Padding(1)
        )

    #db = GreedyRange(record)
    db = Array(99, record)
    dat = db.parse(blob)

    cols = ('ID', 'date', 'time', 'value', 'stat0', 'stat1')
    ret = [", ".join(cols)]

    for i, rec in enumerate(dat):
        for key in ['year', 'week', 'month', 'day', 'hour', 'minute', 'second']:
            rec[key] = bcd2int(rec[key])
        rec['year'] += 2000
        rec['value'] = hex(rec['value'])


        rec = {
            'ID'   : i+1,
            'date' : "%4.4i-%2.2i-%2.2i" % (rec['year'], rec['month'], rec['day']),
            'time' : "%2.2i:%2.2i:%2.2i" % (rec['hour'], rec['minute'], rec['second']),
            'value': rec['value'],
            'stat0': rec['stat0'],
            'stat1': rec['stat1']
            }

        ret.append(", ".join(([str(rec[col]) for col in cols])))

    return("\n".join(ret))


def decode_logger_data(blob):
    "Decode the logger_data binary blob to csv"

    logger_buffer = Struct(
        "data_logger buffer",
        UBInt8('groups'),
        UBInt16('buffersize')
        )
    ret = logger_buffer.parse(blob)

def decode_timing_data(blob):
    "Decode the timing binary blob to csv"

    timing_data = Struct(
        "timing data",
        Padding(1),
        UBInt8('year'),
        UBInt8('week'),
        UBInt8('month'),
        UBInt8('day'),
        UBInt8('hour'),
        UBInt8('minute'),
        UBInt8('second'),
        LFloat32('value'), # XXX is this correct?
        UBInt8('stat0'),
        UBInt8('stat1'),
        UBInt8('mem_no'),
        UBInt8('read_no')
        )
    ret = timing_data.parse(blob)


# command definition
cmd = {
        'units' : { 
            'cmd' : b"\xfe",		# command byte
            'ret' : False,		# will data be returned?
            'desc': "Toggle units between lux and foot candle (fc)"	# description
            },
        'light' : { 
            'cmd' : b"\xfd", 
            'ret' : False,
            'desc': "Toggle backlight"
            },
        'save' : { 
            'cmd' : b"\xfb", 
            'ret' : False,
            'desc': "Mem/setup"
            },
        'peak' : { 
            'cmd' : b"\xf7", 
            'ret' : False,
            'desc': "Toggle peak value display"
            },
        'rel' : { 
            'cmd' : b"\xdf", 
            'ret' : False,
            'desc': "Toggle realtive reading"
            },
        'hold' : { 
            'cmd' : b"\xef", 
            'ret' : False,
            'desc': "Toggle value hold"
            },
        'minmax' : { 
            'cmd' : b"\xbf", 
            'ret' : False,
            'desc': "Toggle Min/Max/current value discplay "
            },
        'logger' : { 
            'cmd' : b"\xdc", 
            'ret' : False,
            'desc': "??? Data logger hold REC"
            },
        'relhold' : { 
            'cmd' : b"\xdb", 
            'ret' : False,
            'desc': ""
            },
        'lighthold' : { 
            'cmd' : b"\xde", 
            'ret' : False,
            'desc': "???"
            },
        'peakhold' : { 
            'cmd' : b"\xda", 
            'ret' : False,
            'desc': "???"
            },
        'range' : { 
            'cmd' : b"\x7f", 
            'ret' : False,
            'desc': "Cycle through measurement ranges"
            },
        'off' : { 
            'cmd' : b"\xf3", 
            'ret' : False,
            'desc': "Turn off the instrument"
            },
        'get-timing' : { 
            'cmd' : b"\x11", 
            'ret' : True,
            'desc': "Timing data transmit"
            },
        'get-stored-data' : { 
            'cmd' : b"\x12", 
            'ret' : True,
            'desc': "Read stored data"
            },
        'get-logger-data' : { 
            'cmd' : b"\x13", 
            'ret' : True,
            'desc': "Read logger data"
            },
        'get-data-protocol' : { 
            'cmd' : b"\x14", 
            'ret' : True,
            'desc': "Data logger data transmit protocol"
            }
        }


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass

# EOF
